#!/usr/bin/env python3
"""
Enhanced Template Manager for agent file generation.

Provides intelligent template generation with validation and customization.
"""
import os
import re
from typing import Dict, Any, List, Tuple

BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
TEMPLATE_DIR = os.path.join(BASE_DIR, 'agents', 'general')


class EnhancedTemplateManager:
    """Enhanced template manager with validation and customization."""
    
    def __init__(self):
        self.template_cache = {}
    
    def _load_template(self, template_name: str) -> str:
        """Load template from file with caching."""
        if template_name in self.template_cache:
            return self.template_cache[template_name]
        
        template_path = os.path.join(TEMPLATE_DIR, template_name)
        if not os.path.exists(template_path):
            raise FileNotFoundError(f"Template not found: {template_name}")
        
        with open(template_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        self.template_cache[template_name] = content
        return content
    
    def generate_agent_file(self, agent_name: str, session: Dict[str, Any]) -> str:
        """Generate agent.py file with intelligent replacements."""
        template = self._load_template('general_agent.py')
        
        class_agent_name = "".join([word.capitalize() for word in agent_name.split("_")]) + "Agent"
        class_server_name = "".join([word.capitalize() for word in agent_name.split("_")]) + "Server"
        
        # Perform intelligent replacements
        replacements = [
            (r'self\.agent_id = "general-1"', f'self.agent_id = "{agent_name}-1"'),
            (r'self\.service_name = "General Agent"', f'self.service_name = "{session.get("name", agent_name)}"'),
            (r'class GeneralAgent:', f'class {class_agent_name}:'),
            (r'from agents\.general\.mcp_server import MCPServer',
             f'from {agent_name}_server import {class_server_name}'),
            (r'GeneralAgent\(', f'{class_agent_name}('),
            (r'MCPServer\(', f'{class_server_name}('),
            (r'"General Agent"', f'"{session.get("name", agent_name)}"'),
        ]
        
        result = template
        for pattern, replacement in replacements:
            result = re.sub(pattern, replacement, result)
        
        # Ensure proper imports
        if f'from {agent_name}_server import {class_server_name}' not in result:
            # Find the import line and replace it
            import_pattern = r'from agents\.general\.mcp_server import MCPServer'
            if re.search(import_pattern, result):
                result = re.sub(import_pattern, f'from {agent_name}_server import {class_server_name}', result)
            else:
                # Add import after other imports
                import_section = 'from shared.protocol import ('
                if import_section in result:
                    idx = result.find(import_section)
                    # Find the line before this import section
                    lines = result[:idx].split('\n')
                    insert_idx = idx
                    for i, line in enumerate(lines):
                        if 'import' in line:
                            insert_idx = result.find('\n', result.find(line)) + 1
                    
                    result = result[:insert_idx] + f'from {agent_name}_server import {class_server_name}\n' + result[insert_idx:]
        
        return result
    
    def generate_server_file(self, agent_name: str) -> str:
        """Generate server.py file with proper imports."""
        template = self._load_template('mcp_server.py')
        
        class_server_name = "".join([word.capitalize() for word in agent_name.split("_")]) + "Server"
        
        # Perform replacements
        replacements = [
            (r'class MCPServer:', f'class {class_server_name}:'),
            (r'from agents\.general\.mcp_tools import TOOL_REGISTRY', 
             f'from {agent_name}_tools import TOOL_REGISTRY'),
            (r'MCPServer\(', f'{class_server_name}('),
        ]
        
        result = template
        for pattern, replacement in replacements:
            result = re.sub(pattern, replacement, result)
        
        return result
    
    def generate_tools_template(self, tool_descriptions: List[Dict] = None) -> str:
        """Generate a tools.py template with suggested tool functions."""
        template = '''"""
MCP Tools â€” tool functions that return UI Primitives.

Generated by AstralBody Agent Creator.
"""
import os
import sys
from typing import Dict, Any, List, Optional

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))

from shared.primitives import (
    Text, Button, Card, Table, List_, Alert, ProgressBar, MetricCard,
    CodeBlock, Image, Grid, Tabs, Divider, Input, BarChart, LineChart,
    PieChart, PlotlyChart, Collapsible, Container,
    create_ui_response
)

'''
        
        if tool_descriptions:
            template += "# Tool functions based on your requirements\n"
            for i, tool_desc in enumerate(tool_descriptions):
                tool_name = tool_desc.get('name', f'tool_{i+1}').replace(' ', '_').lower()
                description = tool_desc.get('description', 'Tool description')
                params = tool_desc.get('parameters', [])
                
                # Generate function signature
                param_strs = []
                for param in params:
                    param_name = param.get('name', 'param')
                    param_type = param.get('type', 'str')
                    type_map = {
                        'string': 'str',
                        'number': 'float',
                        'integer': 'int',
                        'boolean': 'bool',
                        'array': 'List',
                        'object': 'Dict'
                    }
                    python_type = type_map.get(param_type, 'Any')
                    param_strs.append(f'{param_name}: {python_type}')
                
                param_list = ', '.join(param_strs) if param_strs else ''
                
                template += f'''
def {tool_name}({param_list}) -> Dict[str, Any]:
    """{description}"""
    # TODO: Implement {tool_name}
    return create_ui_response([
        Text(content="Implement {tool_name} functionality", variant="body")
    ])

'''
        else:
            template += '''# TODO: Add your tool functions here
# Each function should return a dict with _ui_components and _data keys
# Example:
def example_tool(param1: str) -> Dict[str, Any]:
    """Example tool description"""
    return create_ui_response([
        Text(content=f"Result: {param1}", variant="body")
    ])

'''
        
        # Add TOOL_REGISTRY
        template += '''
# Tool registry
TOOL_REGISTRY = {
'''
        
        if tool_descriptions:
            for i, tool_desc in enumerate(tool_descriptions):
                tool_name = tool_desc.get('name', f'tool_{i+1}').replace(' ', '_').lower()
                description = tool_desc.get('description', 'Tool description')
                params = tool_desc.get('parameters', [])
                
                # Generate input schema
                properties = {}
                required = []
                for param in params:
                    param_name = param.get('name', 'param')
                    param_type = param.get('type', 'string')
                    param_desc = param.get('description', 'Parameter description')
                    
                    properties[param_name] = {
                        "type": param_type,
                        "description": param_desc
                    }
                    if param.get('required', False):
                        required.append(param_name)
                
                input_schema = {
                    "type": "object",
                    "properties": properties
                }
                if required:
                    input_schema["required"] = required
                
                template += f'''    "{tool_name}": {{
        "function": {tool_name},
        "description": "{description}",
        "input_schema": {input_schema}
    }},
'''
        else:
            template += '''    # "example_tool": {
    #     "function": example_tool,
    #     "description": "Example tool description",
    #     "input_schema": {
    #         "type": "object",
    #         "properties": {
    #             "param1": {"type": "string", "description": "Example parameter"}
    #         },
    #         "required": ["param1"]
    #     }
    # }
'''
        
        template += '''}
'''
        
        return template
    
    def generate_all_templates(self, agent_name: str, session: Dict[str, Any], 
                              tool_descriptions: List[Dict] = None) -> Dict[str, str]:
        """Generate all three template files."""
        return {
            "tools": self.generate_tools_template(tool_descriptions),
            "agent": self.generate_agent_file(agent_name, session),
            "server": self.generate_server_file(agent_name)
        }
    
    def validate_templates(self, templates: Dict[str, str]) -> List[Tuple[str, str]]:
        """Validate generated templates for common issues."""
        issues = []
        
        for file_type, content in templates.items():
            # Check for placeholder TODOs
            if 'TODO:' in content:
                issues.append((file_type, "Contains TODO comments that need implementation"))
            
            # Check for missing imports
            if file_type == "tools":
                if 'from shared.primitives import' not in content:
                    issues.append((file_type, "Missing shared.primitives import"))
                if 'TOOL_REGISTRY' not in content:
                    issues.append((file_type, "Missing TOOL_REGISTRY definition"))
            
            # Check for syntax issues (basic check)
            if 'import ' in content and '\nimport ' in content:
                # Check for duplicate imports
                import_lines = [line for line in content.split('\n') if line.strip().startswith('import ')]
                if len(import_lines) != len(set(import_lines)):
                    issues.append((file_type, "Duplicate import statements"))
        
        return issues


# Singleton instance
enhanced_template_manager = EnhancedTemplateManager()


if __name__ == "__main__":
    # Test the template generation
    test_session = {
        "name": "Test Agent",
        "persona": "A test agent for demonstration"
    }
    
    tool_descriptions = [
        {
            "name": "fetch_data",
            "description": "Fetch data from an API",
            "parameters": [
                {"name": "url", "type": "string", "description": "API endpoint URL", "required": True},
                {"name": "format", "type": "string", "description": "Response format (json/xml)", "required": False}
            ]
        }
    ]
    
    manager = EnhancedTemplateManager()
    templates = manager.generate_all_templates("test_agent", test_session, tool_descriptions)
    
    print(f"Generated {len(templates)} templates")
    for key, content in templates.items():
        print(f"\n=== {key}.py === (first 300 chars)")
        print(content[:300])
    
    issues = manager.validate_templates(templates)
    if issues:
        print(f"\nValidation issues:")
        for file_type, issue in issues:
            print(f"  {file_type}: {issue}")
    else:
        print("\nAll templates validated successfully!")
